using Helix.Common;
using Helix.Engine.Configuration;
using Helix.Engine.Extensions;
using System.Data.Common;
using System.Text;

namespace Helix.Engine.Metadata.Postgres
{
    internal class PostgresMetadataProvider : IMetadataProvider
    {
        public DatabaseVendor DatabaseVendor => DatabaseConfiguration.Vendor;

        public string DatabaseName => DatabaseConfiguration.Name;

        internal DatabaseConfiguration DatabaseConfiguration { get; private set; }

        private IEnumerable<ITableDescriptor> _tablesDescriptors;

        public IEnumerable<ITableDescriptor> TableDescriptors { get { return _tablesDescriptors; } }

        public PostgresMetadataProvider(DatabaseConfiguration configuration)
        {
            DatabaseConfiguration = configuration;
        }

        private string DatabaseDescriptorSql = @"
			select table_schema
				, table_name 
				, column_name 
				, ordinal_position
				, is_nullable 
				, data_type 
				, character_maximum_length 
				, coalesce ((
	
					select 'YES'
					FROM pg_index, pg_class, pg_attribute, pg_namespace 
					WHERE 
					  indrelid = pg_class.oid 
					  and nspname = c.table_schema
					  and relname = c.table_name
					  and attname = c.column_name
					  and pg_class.relnamespace = pg_namespace.oid 
					  and pg_attribute.attrelid = pg_class.oid 
					  and pg_attribute.attnum = any(pg_index.indkey)
					  AND indisprimary
	
				), 'NO') is_primary_key
				, (
					SELECT
						pg_catalog.col_description(cl.oid, c.ordinal_position::int)
					FROM
						pg_catalog.pg_class cl
					WHERE
						cl.oid = (SELECT ('""' || c.table_name || '""')::regclass::oid)
						AND cl.relname = c.table_name
				) AS column_comment
				, (
					select rel_tco.table_name
					/* kcu.table_schema || '.' ||kcu.table_name as foreign_table,
					       rel_tco.table_schema || '.' || rel_tco.table_name as primary_table,
					       string_agg(kcu.column_name, ', ') as fk_columns,
					       kcu.constraint_name
					*/
					from information_schema.table_constraints tco
					join information_schema.key_column_usage kcu
					          on tco.constraint_schema = kcu.constraint_schema
					          and tco.constraint_name = kcu.constraint_name
					join information_schema.referential_constraints rco
					          on tco.constraint_schema = rco.constraint_schema
					          and tco.constraint_name = rco.constraint_name
					join information_schema.table_constraints rel_tco
					          on rco.unique_constraint_schema = rel_tco.constraint_schema
					          and rco.unique_constraint_name = rel_tco.constraint_name
					where tco.constraint_type = 'FOREIGN KEY'
					and   kcu.table_schema = c.table_schema 
					and   kcu.table_name = c.table_name -- migrate to left joins
                    and   kcu.column_name = c.column_name 
					group by kcu.table_schema,
					         kcu.table_name,
					         rel_tco.table_name,
					         rel_tco.table_schema,
					         kcu.constraint_name
				) ""references""
			from information_schema.columns c
			where table_schema = '$$schema$$'
			order by table_schema, table_name, ordinal_position 
		";

        public async Task LoadDescriptorsAsync()
        {
            using (var connection = ConnectionFactory.GetNew(
                DatabaseConfiguration.ConnectionString,
                DatabaseConfiguration.Vendor))
            {
                connection.Open();

                var command = connection.CreateCommand();
                command.CommandText = DatabaseDescriptorSql
                    .Replace("$$schema$$", DatabaseConfiguration.Schema ?? "public");

                var reader = await command.ExecuteReaderAsync();

                var cols = ReadAllAsync(reader);

                var tables = cols.GroupBy(x => x.Table);

                if (!Directory.Exists(DatabaseDescriptorSql))
                {
                    Directory.CreateDirectory(Path.Join(DatabaseConfiguration.BaseDirectory, @"Tables"));
                }

                foreach (var table in tables)
                {
                    var baseTemplate = @$"using Helix.Core;
using Helix.Common;
using System.ComponentModel.DataAnnotations;
using System.Diagnostics.CodeAnalysis;

/* * * * * * * * * * * * * * * * * * * ** 
 *                                      *
 *  THIS CLASS WAS GENERATED BY HELIX   *
 *                                      *
 *  DO NOT EDIT THIS CLASS!             *
 *                                      *
 *  For more information:               *
 *  https://github.com/diegosiao/helix  *
 *                                      *
 * * * * * * * * * * * * * * * * * * * **/


namespace {DatabaseConfiguration.DomainNamespace}
{{
    [SuppressMessage(
        ""Style"", ""IDE1006:Naming Styles"", Justification = ""Helix 'never map' premise"")]
	public sealed partial class {table.Key} : DbTuple
	{{
$$properties$$

        private const string INSERT_TEMPLATE =
            @""$$insertTemplate$$"";

        private const string UPDATE_TEMPLATE =
            @""$$updateTemplate$$"";

        private const string SELECT_TEMPLATE =
            @""$$selectTemplate$$"";

        private const string DELETE_TEMPLATE =
            @""$$selectTemplate$$"";

        public {table.Key}() : base(
            INSERT_TEMPLATE,
            UPDATE_TEMPLATE,
            SELECT_TEMPLATE,
            DELETE_TEMPLATE) 
        {{ }}
	}}
}}
";
                    var properties = new StringBuilder();
                    var insertTemplate = $@"
                        INSERT INTO {table.Key} (
$columns$
                        ) 
                        VALUES (
$values$
                        )";

                    foreach (var column in table)
                    {
                        if (!string.IsNullOrEmpty(column.Comment))
                        {
                            properties.AppendLine("        /// <sumary>");
                            properties.AppendLine($"        /// {column.Comment}");
                            properties.AppendLine("        /// </summary>");
                        }

                        if (column.IsPrimaryKey)
                        {
                            properties.AppendLine("        [Key]");
                        }

                        if (!string.IsNullOrWhiteSpace(column.References))
                        {
                            properties.AppendLine($"        [References(typeof({column.References}))]");
                        }

                        properties.AppendLine(
                            $"        public {column.TypeDescriptor.ApplicationType.UnboxedName(column.IsNullable)} {column.Name} {{ get; set; }}");
                        properties.AppendLine(string.Empty);
                    }

                    insertTemplate = insertTemplate.Replace(
                        "$columns$",
                        string.Join(@$",{Environment.NewLine}", table.Select(x => $"                            {x.Name}")));

                    insertTemplate = insertTemplate.Replace(
                        "$values$",
                        string.Join($@",{Environment.NewLine}", table.Select(x => $"                            @{x.Name}")));

                    baseTemplate = baseTemplate
                        .Replace("$$properties$$", properties.ToString())
                        .Replace("$$insertTemplate$$", insertTemplate);

                    File.WriteAllText(
                        Path.Join(DatabaseConfiguration.BaseDirectory, $"Tables/{table.Key}.cs"),
                        baseTemplate);
                }
            }
        }

        private IEnumerable<PostgresColumnDescriptor> ReadAllAsync(DbDataReader reader)
        {
            while (reader.Read())
            {
                yield return new PostgresColumnDescriptor
                {
                    Schema = reader.GetString(0),
                    Table = reader.GetString(1),
                    Name = reader.GetString(2),
                    OrdinalPosition = reader.GetInt32(3),
                    IsNullable = "YES".Equals(reader.GetString(4)),
                    TypeDescriptor = PostgresSupportedTypes.Types[reader.GetString(5)],
                    Length = reader.IsDBNull(6) ? null : reader.GetInt32(6),
                    IsPrimaryKey = "YES".Equals(reader.GetString(7)),
                    Comment = reader.IsDBNull(8) ? null : reader.GetString(8),
                    References = reader.IsDBNull(9) ? null : reader.GetString(9),
                };
            }
        }
    }
}
